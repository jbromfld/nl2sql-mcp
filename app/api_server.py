"""
FastAPI for NL2SQL Service

Provides REST endpoints for the two-phase NL2SQL process:
- POST /prepare - Extract slots, check cache, return schema
- POST /execute - Execute SQL and cache
- GET /cache/stats - Cache statistics
- GET /cache/list - List cached queries
"""

import os
from typing import Optional, Dict, Any
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
from dotenv import load_dotenv

# Import the NL2SQL tools
from nl2sql_tools import NL2SQLTools

load_dotenv()

app = FastAPI(
    title="NL2SQL API",
    description="Natural Language to SQL conversion with distributed caching",
    version="1.0.0"
)

# Database configuration
DB_CONNECTION = os.getenv("DATABASE_URL")
if not DB_CONNECTION:
    raise ValueError("DATABASE_URL environment variable is required")

# Initialize NL2SQL tools (one instance per request, but could use connection pooling)
def get_tools(user_id: Optional[str] = None):
    """Get NL2SQL tools instance with user context"""
    return NL2SQLTools(DB_CONNECTION, user_id)


# ============================================================================
# Request/Response Models
# ============================================================================

class PrepareRequest(BaseModel):
    """Request model for /prepare endpoint"""
    query: str = Field(..., description="Natural language query")
    user_id: Optional[str] = Field(None, description="User identifier for cache attribution")

    model_config = {"json_schema_extra": {
        "example": {
            "query": "Show me deployments for frontend in the last week",
            "user_id": "john.doe@company.com"
        }
    }}


class ExecuteRequest(BaseModel):
    """Request model for /execute endpoint"""
    sql: str = Field(..., description="SQL query to execute")
    cache_key: str = Field(..., description="Cache key from nl2sql_prepare")
    confirm_cache: bool = Field(True, description="Whether to cache this SQL for future use")
    user_id: Optional[str] = Field(None, description="User identifier for cache attribution")

    model_config = {"json_schema_extra": {
        "example": {
            "sql": "SELECT * FROM deployment_data WHERE app_name = 'frontend'",
            "cache_key": "SELECT:deployment_data:frontend:*:weeks:1:*",
            "confirm_cache": True,
            "user_id": "john.doe@company.com"
        }
    }}


class CacheDeleteRequest(BaseModel):
    """Request model for /cache/delete endpoint"""
    cache_key: str = Field(..., description="Cache key to delete")

    model_config = {"json_schema_extra": {
        "example": {
            "cache_key": "SELECT:deployment_data:frontend:*:weeks:1:*"
        }
    }}


class CacheCleanupRequest(BaseModel):
    """Request model for /cache/cleanup endpoint"""
    days_old: int = Field(90, description="Remove entries not used in N days", ge=1)

    model_config = {"json_schema_extra": {
        "example": {
            "days_old": 90
        }
    }}


class ErrorResponse(BaseModel):
    """Standard error response"""
    status: str = "error"
    message: str


# ============================================================================
# API Endpoints
# ============================================================================

@app.post("/prepare", summary="Prepare NL query for SQL generation")
async def prepare(request: PrepareRequest) -> Dict[str, Any]:
    """
    Phase 1: Prepare natural language query for SQL generation

    Extracts slots, checks distributed cache, and either returns results directly
    (cache hit) or provides context for SQL generation (cache miss).

    **Cache hit response:**
    - status: "success"
    - cached: true
    - results: Query results
    - sql: Cached SQL query

    **Cache miss response:**
    - status: "needs_generation"
    - cached: false
    - slots: Extracted query parameters
    - schema: Database schema info
    - instruction: SQL generation guidance
    """
    try:
        user_id = request.user_id or 'api_user'

        # Get tools instance
        tools = get_tools(user_id)

        # Prepare the query
        result = tools.nl2sql_prepare(request.query)

        # Return appropriate status code
        if result.get("status") == "error":
            raise HTTPException(status_code=400, detail=result)

        return result

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={"status": "error", "message": f"Internal server error: {str(e)}"}
        )


@app.post("/execute", summary="Execute SQL and cache")
async def execute(request: ExecuteRequest) -> Dict[str, Any]:
    """
    Phase 2: Execute generated SQL and optionally cache it

    Takes the SQL query (generated by LLM or manually), executes it, and
    caches it for future use if successful.

    **Response:**
    - status: "success" or "error"
    - results: Query results
    - row_count: Number of rows returned
    - sql: Executed SQL query
    - cached: Whether query was cached
    """
    try:
        user_id = request.user_id or 'api_user'

        # Get tools instance
        tools = get_tools(user_id)

        # Execute the SQL
        result = tools.nl2sql_execute(request.sql, request.cache_key, request.confirm_cache)

        # Return appropriate status code
        if result.get("status") == "error":
            raise HTTPException(status_code=400, detail=result)

        return result

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={"status": "error", "message": f"Internal server error: {str(e)}"}
        )


@app.get("/cache/stats", summary="Get cache statistics")
async def cache_stats() -> Dict[str, Any]:
    """
    Get distributed cache statistics

    **Response:**
    - total_entries: Number of cached queries
    - total_hits: Total cache hits across all queries
    - avg_uses_per_query: Average reuse rate
    - unique_users: Number of unique users
    - top_queries: Most frequently used queries
    """
    try:
        tools = get_tools()
        stats = tools.nl2sql_cache_stats()
        return stats

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={"status": "error", "message": f"Failed to get cache stats: {str(e)}"}
        )


@app.get("/cache/list", summary="List cached queries")
async def cache_list(limit: int = 50) -> Dict[str, Any]:
    """
    List cached queries with metadata

    **Query Parameters:**
    - limit: Number of entries to return (default: 50)

    **Response:**
    - cached_queries: List of cache entries with metadata
    - total_shown: Number of entries returned
    """
    try:
        tools = get_tools()
        result = tools.nl2sql_cache_list(limit)
        return result

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={"status": "error", "message": f"Failed to list cache: {str(e)}"}
        )


@app.delete("/cache/delete", summary="Delete cache entry")
async def cache_delete(request: CacheDeleteRequest) -> Dict[str, Any]:
    """
    Delete a specific cache entry

    **Response:**
    - status: "success" or "not_found"
    - message: Deletion result message
    """
    try:
        tools = get_tools()
        result = tools.nl2sql_cache_delete(request.cache_key)
        return result

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={"status": "error", "message": f"Failed to delete cache entry: {str(e)}"}
        )


@app.post("/cache/cleanup", summary="Cleanup old cache entries")
async def cache_cleanup(request: CacheCleanupRequest) -> Dict[str, Any]:
    """
    Remove cache entries not used in N days

    **Response:**
    - status: "success"
    - deleted_count: Number of entries removed
    - message: Cleanup summary
    """
    try:
        tools = get_tools()
        result = tools.nl2sql_cache_cleanup(request.days_old)
        return result

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={"status": "error", "message": f"Failed to cleanup cache: {str(e)}"}
        )


@app.get("/health", summary="Health check")
async def health() -> Dict[str, str]:
    """Health check endpoint"""
    return {
        "status": "healthy",
        "service": "nl2sql-api"
    }


if __name__ == '__main__':
    import uvicorn

    # Development server configuration
    port = int(os.getenv('PORT', 8088))
    reload = os.getenv('DEBUG', 'False').lower() == 'true'

    uvicorn.run(
        "api_server:app",
        host='0.0.0.0',
        port=port,
        reload=reload,
        log_level="info"
    )
